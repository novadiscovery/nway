// (The MIT License)
//
// Copyright (c) 2012-2013 Novadiscovery <osproject@novadiscovery.com>
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// 'Software'), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// IMPORTS
var fs        = require('fs')
  , mkdirp    = require('mkdirp')
  , async     = require('async')
  , _         = require('underscore')
  , debug     = require('debug')('nway:builder:standard')
  , total     = require('debug')('nway:builder:standard:total')
  , defaults  = require('../defaultOptions')
  , buildTree = require('../buildTree')
  , parser    = require('../parser')
  , Bootstrap = require('../Bootstrap')
;

// EXPORT
module.exports = standard;

/**
 * No error constructor
 *
 * NoErrorEnd is used by the asynchronous process
 * to stop the processus without returning an error to
 * the global callback. This is a kind of *break* when
 * a destination packet file is allready generated.
 *
 * @api private
 */
function NoErrorEnd() {}


/**
 * The standard builder : generate the bootstrap and the packets files
 * in the output folder.
 *
 * The result object returned to the builder is :
 *
 *     {
 *         // The dependencie tree (generated by buildTree)
 *         , tree         : tree
 *
 *         // All the packets objects
 *         , packets      : packets
 *
 *         // List of the packet that have been generated
 *         // (some packets are not generated if the destination file
 *         // allready exists)
 *         , incBundles   : incBundles
 *
 *     }
 *
 * @param  {object}   options  nway options (see defaultOptions)
 * @param  {Function} callback A callback that receive an error and a resulte object
 * @api public
 */
function standard(options, callback) {
	total('Start'); // Total is a time debug()

	var options   = _.extend({}, defaults, options)
	  , callback  = (callback || function() {})
	  , tree
	  , packets
	  , incBundles = []
	;

	// BUILD FLOW

/**
 * Step 1
 *
 * Prepare builder information using nway.prepare() :
 * modules object, root module, sources, tree and packet list
 *
 * @api private
 */
	function initialize(done) {
		debug('prepare');

		parser(options.index, options, function(err,  modules) {
			if(err) return done(err)

			debug('Parser return, now build the tree...');
			tree          = buildTree(options, modules, true);

			debug('Tree builded');

			// Extract from tree as a flatten list of packets to compile
			packets       = tree.getAllBundles(options);

			done(null);
		})

	}

/**
 * Step 2
 *
 * Create the required directories :
 *
 *   - output directory
 *
 * @api private
 */
	function createDirectories(done) {
		debug('createDirectories()');
		var paths = [ options.output ];
		function iterator(dirpath, next) { mkdirp(dirpath, '0755', next); };
		async.forEach(paths, iterator, done);
	}


/**
 * Step 3
 *
 * Apply packet the packet exclusion process : if a packet is allready generated
 * (with the same hash key) then the packet is removed from the generator
 * stack.
 *
 * If the generator stack is empty, then the NoErrorEnd() object returned to the
 * callback stop the generation process.
 *
 * @api private
 */
	function excludeBundles(done) {
		debug('excludeBundles()');

		// With force options to true : do not exclude any packet
		if(options.force) {
			incBundles = packets;
			return done();
		}

		// Check the existence of all the packets output files :
		async.forEach(packets, function(packet, next) {
			fs.stat(packet.makePath(options), function(err) {
				// Packet doesn't exits : add it to packets to compile :
				if(err) incBundles.push(packet);
				next();
			});
		}, function() {
			if(!incBundles.length) {
				// Stop generation process if all the packets are allready
				// generated

				//return done(new NoErrorEnd()); // !! Bug : we nee to rewrite the
				//bootstrap anyway !!
			}
			done();
		});
	}



/**
 * Step 5
 *
 * Call write() on all packets
 *
 * @api private
 */
	function writeBundles(done) {
		debug('writeBundles()');
		async.forEachSeries(incBundles, function(packet, next) {
			packet.write(options, next);
		}, done);
	}

/**
 * Step 8
 *
 * Wite the boostrap file
 *
 * @api private
 */
	function writeBootstrap(done) {
		var bootstrap = new Bootstrap();
		bootstrap.write(tree, options, done);
	}

	// Run asynchronous flow :
	async.series([
		  initialize               // Step 1
		, createDirectories        // Step 2
		, excludeBundles           // Step 3
		, writeBundles             // Step 5
		, writeBootstrap           // Step 8
	],function(err) {
		total('End');

		// Prepare the result object returned to the
		// builder() callback
		var result = {
			  packets      : packets
			, incBundles   : incBundles
			, tree         : tree
		}

		if(!err || (err instanceof NoErrorEnd)) {
			return callback(null, result);
		} else {
			return callback(err, result);
		}
	});


}
